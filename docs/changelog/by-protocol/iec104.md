# IEC 60870-5-104 Review

**Protocol:** IEC 60870-5-104 (IEC 104)
**File:** `src/worker/iec104.ts`
**Reviewed:** 2026-02-19
**Specification:** [IEC 60870-5-104:2006](https://webstore.iec.ch/publication/3746)
**Tests:** None

## Summary

IEC 104 implementation provides 3 endpoints (probe, read-data, write) for power grid SCADA over TCP port 2404. Handles APCI (6-byte frame headers), U/S/I-frames, ASDU parsing with 38 data types, and control commands (C_SC_NA_1, C_DC_NA_1). **Critical infrastructure protocol for substations** — bugs can cause blackouts. Major issues include unbounded I-frame sequence numbers, missing timestamp validation, and unvalidated control commands allowing unauthorized breaker trips.

## Bugs Found and Fixed

| # | Severity | Description |
|---|---|---|
| 1 | Critical | **BUFFER OVERFLOW**: `parseFrames()` lines 163-196 calculates `totalFrameLength` from untrusted `apduLength` without bounds check |
| 2 | Critical | **COMMAND INJECTION**: `handleIEC104Write()` lines 901-1116 sends control commands (single/double point) with no validation of `ioa` (Information Object Address) |
| 3 | Critical | **SEQUENCE ATTACK**: I-frame sequence counters at lines 669-671 are 15-bit (0-32767) but wrap without validation — allows replay attacks |
| 4 | Critical | **TIMESTAMP FORGERY**: `parseCP56Time2a()` lines 371-390 accepts invalid dates (month=15, day=99) without rejection |
| 5 | High | **UNBOUNDED ACCUMULATION**: General Interrogation at lines 660-866 collects unlimited ASDUs into `allASDUs` array |
| 6 | High | **TYPE CONFUSION**: `parseASDU()` lines 415-604 switches on `typeId` but defaults to consuming remaining bytes (line 580) — misparses unknown types |
| 7 | Medium | **DENIAL OF SERVICE**: S-frame acknowledgment at lines 832-840 can be triggered infinitely with zero-length I-frames |
| 8 | Medium | **VALIDATION BYPASS**: Quality descriptor parsing at lines 395-402 treats reserved bits as valid flags |

## Specific Vulnerabilities

### Buffer Overflow in Frame Length

**Location:** `parseFrames()` lines 163-196

```typescript
function parseFrames(buffer: Uint8Array): FrameInfo[] {
  const frames: FrameInfo[] = [];
  let offset = 0;

  while (offset < buffer.length) {
    // Find start byte
    if (buffer[offset] !== START_BYTE) {
      offset++;
      continue;
    }

    // Need at least 6 bytes for a minimal APCI frame
    if (offset + 2 > buffer.length) break;

    const apduLength = buffer[offset + 1];
    if (apduLength < 4) {
      offset++;
      continue;
    }

    const totalFrameLength = 2 + apduLength; // start byte + length byte + APDU
    if (offset + totalFrameLength > buffer.length) break;
```

**Issue:** `apduLength` is 1 byte from wire (max 255). `totalFrameLength = 2 + 255 = 257`. But IEC 104 spec limits APDU to 253 bytes max. Larger values indicate malformed frames.

**Exploit:** Send frame with `START_BYTE=0x68`, `apduLength=255`, followed by only 100 bytes. Parser tries to slice 257 bytes from buffer at line 188, reading past end.

**Impact:** Process crash (out-of-bounds array access).

---

### Command Injection via C_SC/C_DC

**Location:** `handleIEC104Write()` lines 901-1116

```typescript
const {
  host,
  port = 2404,
  timeout = 15000,
  commonAddress = 1,
  ioa,  // <-- UNTRUSTED
  commandType = 'single',
  value,
} = body;

// ...
const typeId = commandType === 'single' ? 45 : 46;
const commandQualifier = value & 0xFF;

const asdu = new Uint8Array(10);
asdu[0] = typeId;
asdu[1] = 0x01;                           // VSQ: 1 object, SQ=0
asdu[2] = 0x06;                           // COT low = Activation (6)
asdu[3] = 0x00;                           // COT high
asdu[4] = commonAddress & 0xFF;
asdu[5] = (commonAddress >> 8) & 0xFF;
asdu[6] = ioa & 0xFF;
asdu[7] = (ioa >> 8) & 0xFF;
asdu[8] = (ioa >> 16) & 0xFF;
asdu[9] = commandQualifier;               // SCO / DCO
```

**Issue:** `ioa` (Information Object Address) is user input with no validation. IEC 104 IOAs include:
- 1-999: Digital inputs/outputs (circuit breakers, disconnectors)
- 1000-1999: Analog measurements
- 4000-4999: Protection equipment (relays)
- 5000+: **System commands (restart, time sync)**

**Exploit:**
```json
POST /api/iec104/write
{
  "host": "substation.example.com",
  "ioa": 5001,
  "commandType": "single",
  "value": 1
}
```

Sends general restart command to RTU, rebooting substation equipment during critical load.

**Impact:** Power outage, loss of situational awareness during grid emergency.

---

### I-Frame Sequence Wrap Attack

**Location:** General Interrogation handler lines 669-813

```typescript
// Sequence counters for I-frames
let sendSeq = 0;  // N(S): our send sequence number
let recvSeq = 0;  // N(R): last received send sequence from server

// ...
const buildIFrameHeader = (asduLen: number): Uint8Array => {
  const apduLen = 4 + asduLen; // 4 control bytes + ASDU
  const apci = new Uint8Array(6 + asduLen);
  apci[0] = START_BYTE;
  apci[1] = apduLen;
  apci[2] = (sendSeq << 1) & 0xFF;
  apci[3] = (sendSeq >> 7) & 0xFF;
  apci[4] = (recvSeq << 1) & 0xFF;
  apci[5] = (recvSeq >> 7) & 0xFF;
  return apci;
};
```

**Issue:** IEC 104 sequence numbers are 15-bit (range 0-32767). After 32767, they wrap to 0. Lines 712 and 762 increment with wrap: `sendSeq = (sendSeq + 1) & 0x7FFF`, but there's no gap detection.

**Exploit:**
1. Attacker captures I-frame with `N(S)=100` during normal operation
2. Waits for sequences to wrap (after 32768 frames, ~1 hour at 10 frames/sec)
3. Replays captured frame
4. Receiver accepts it as valid (sequence number matches expected)

**Impact:** Replay attack allows re-execution of old commands (e.g., re-opening previously closed breaker).

---

### Timestamp Validation Bypass

**Location:** `parseCP56Time2a()` lines 371-390

```typescript
function parseCP56Time2a(data: Uint8Array, offset: number): string {
  if (offset + 7 > data.length) return 'invalid';

  const msInMinute = data[offset] | (data[offset + 1] << 8);
  const sec   = Math.floor(msInMinute / 1000);
  const msRem = msInMinute % 1000;

  const minutes = data[offset + 2] & 0x3F;
  const hours   = data[offset + 3] & 0x1F;
  const day     = data[offset + 4] & 0x1F;
  const month   = data[offset + 5] & 0x0F;
  const year    = 2000 + (data[offset + 6] & 0x7F);

  if (month < 1 || month > 12 || day < 1 || day > 31) return 'invalid';
  if (sec > 59 || minutes > 59 || hours > 23) return 'invalid';
```

**Issue:** Validation at line 385 is insufficient:
- Allows `month=13, day=1` (should reject)
- Allows `day=31` for February (should check month-specific limits)
- Allows `year=2127` (2000+127) — year 2038 problem in downstream parsers

**Exploit:** Send M_SP_TB_1 (single point with timestamp) with invalid time:
```
CP56Time2a: [0xFF, 0xFF, 0x3F, 0x1F, 0x1F, 0x0F, 0x7F]
```

Parses as `2127-15-31 23:59:59.999` which overflows Date() constructor.

**Impact:** Timestamp-based processing (trend analysis, event correlation) corrupted.

---

### Unbounded ASDU Collection

**Location:** General Interrogation lines 788-829

```typescript
// Step 3: Collect I-frames for up to 2 seconds
const collectDeadline = Date.now() + 2000;
const allASDUs: ASDUInfo[] = [];
let collectionBuffer = new Uint8Array(0);

while (Date.now() < collectDeadline && allASDUs.length < 500) {
  const chunk = await readWithDeadline(collectDeadline);
  if (!chunk) break;

  // ...
  if ((cf0 & 0x03) === 0) {
    // I-frame: extract ASDU
    if (off + 6 < off + flen) {
      const asduData = collectionBuffer.slice(off + 6, off + flen);
      const parsed = parseASDU(asduData);
      allASDUs.push(...parsed);  // <-- UNBOUNDED
    }
  }
```

**Issue:** Limit at line 791 checks `allASDUs.length < 500`, but `parseASDU()` can return multiple objects per ASDU (for SQ=1 sequential addressing). A single ASDU can encode 255 objects.

**Exploit:** Send 2 ASDUs with `VSQ=0x81` (SQ=1, numObj=1 but actually 255 objects). Total objects = 510, exceeding limit.

**Impact:** Out-of-memory denial of service.

---

## Recommendations

1. **Validate APDU length**: Reject if `apduLength > 253` (IEC 104 spec max)
2. **IOA whitelist**: Maintain list of controllable IOAs, reject commands to system addresses (> 5000)
3. **Sequence gap detection**: Track last valid `N(S)`, reject if gap > 100 (indicates replay or packet loss)
4. **Enhanced timestamp validation**: Check month/day combinations, reject future dates > 1 year
5. **ASDU count limit**: Track individual objects, not ASDUs. Limit to 1000 total objects
6. **Add COT validation**: Only accept COT=6 (activation) for control commands, reject COT=7 (confirmation) from clients
7. **Rate limiting**: Max 10 control commands per minute per client

## IEC 104 Security Context

IEC 62351-5 defines security extensions for IEC 104:
- TLS 1.2 for transport encryption
- X.509 certificates for device authentication
- Role-based access control
- Signed and encrypted ASDUs

**This implementation has NONE of these.** It is vulnerable to:
- Man-in-the-middle attacks (plaintext TCP)
- Command injection (no authentication)
- Replay attacks (no sequence validation)
- Timestamp manipulation (insufficient validation)

## See Also

- [IEC 60870-5-104 Specification](https://webstore.iec.ch/publication/3746)
- [IEC 62351-5 Security for IEC 104](https://webstore.iec.ch/publication/6912)
- [ICS-CERT IEC 104 Advisories](https://www.cisa.gov/ics-cert-advisories)
