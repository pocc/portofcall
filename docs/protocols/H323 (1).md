# H.323 (Packet-Based Multimedia Communications)

## Overview

**H.323** is an ITU-T recommendation that defines protocols for multimedia communication over packet-switched networks. It was one of the first VoIP standards and is still used in enterprise video conferencing, legacy systems, and interoperability with PSTN gateways.

**Port:** 1720 (TCP, signaling), 1719 (UDP, RAS), dynamic (RTP/RTCP)
**Transport:** TCP (signaling), UDP (RAS, media)
**Status:** Legacy (being replaced by SIP)

## Protocol Specification

### H.323 Protocol Stack

H.323 is actually a suite of protocols:

```
+----------------------------------------------------------+
|                   H.323 Applications                     |
+----------------------------------------------------------+
| H.225 Call Signaling | H.245 Control | H.225 RAS (GK)  |
+----------------------------------------------------------+
|              RTP/RTCP (Media Transport)                  |
+----------------------------------------------------------+
|                  TCP        |        UDP                 |
+----------------------------------------------------------+
|                           IP                             |
+----------------------------------------------------------+
```

**Component Protocols:**
- **H.225 Call Signaling**: Call setup/teardown (port 1720, TCP)
- **H.225 RAS**: Registration, Admission, Status with Gatekeeper (port 1719, UDP)
- **H.245**: Control channel for capabilities and media control (dynamic TCP)
- **RTP/RTCP**: Real-time media transport
- **T.120**: Data conferencing (optional)
- **Codecs**: G.711, G.722, G.729, H.261, H.263, H.264

### H.225 Call Signaling Messages

Based on Q.931 (ISDN signaling):

- **Setup**: Initiate call
- **Call Proceeding**: Acknowledge setup
- **Alerting**: Ringing
- **Connect**: Call answered
- **Release Complete**: Hang up
- **Facility**: Additional call services
- **Progress**: Call progress information

### H.225 Setup Message Structure

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Protocol Disc.|  Call Ref Len |    Call Reference (3 bytes)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Msg Type    |                                               |
+-+-+-+-+-+-+-+-+           Information Elements                |
|                          (ASN.1 PER encoded)                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- **Protocol Discriminator**: 0x08 (Q.931)
- **Call Reference**: Unique call identifier
- **Message Type**: 0x05 (Setup), 0x07 (Connect), etc.
- **Information Elements**: Encoded using ASN.1 PER

### H.245 Control Channel

Establishes after H.225 call setup for:

- **Capability exchange**: Codecs supported
- **Master/Slave determination**: Who controls the call
- **Logical channel signaling**: Open/close media streams
- **Mode request**: Change codec or parameters

### H.225 RAS Messages

For Gatekeeper communication (optional):

- **GRQ** (Gatekeeper Request): Discover gatekeeper
- **GCF** (Gatekeeper Confirm): Gatekeeper response
- **RRQ** (Registration Request): Register with gatekeeper
- **RCF** (Registration Confirm): Registration accepted
- **ARQ** (Admission Request): Request call admission
- **ACF** (Admission Confirm): Admission granted
- **DRQ** (Disengage Request): End call
- **DCF** (Disengage Confirm): Disengage acknowledged

## Worker Implementation

```typescript
// workers/h323.ts
import { connect } from 'cloudflare:sockets';

interface H323Config {
  server: string;
  port?: number;
  callingNumber?: string;
  calledNumber?: string;
}

interface H323Response {
  success: boolean;
  callSetup?: boolean;
  error?: string;
  messages?: string[];
}

const Q931MessageType = {
  ALERTING: 0x01,
  CALL_PROCEEDING: 0x02,
  CONNECT: 0x07,
  SETUP: 0x05,
  RELEASE_COMPLETE: 0x5A,
  FACILITY: 0x62,
  PROGRESS: 0x03,
} as const;

class H323Client {
  private config: Required<H323Config>;
  private socket: any = null;
  private callRef: number = 0;
  private messages: string[] = [];

  constructor(config: H323Config) {
    this.config = {
      server: config.server,
      port: config.port || 1720,
      callingNumber: config.callingNumber || '1000',
      calledNumber: config.calledNumber || '2000',
    };

    // Generate random call reference
    this.callRef = Math.floor(Math.random() * 0x7FFF);
  }

  async connect(): Promise<void> {
    this.socket = connect({
      hostname: this.config.server,
      port: this.config.port,
    });
  }

  async setupCall(): Promise<H323Response> {
    if (!this.socket) {
      await this.connect();
    }

    try {
      // Send Setup message
      const setup = this.buildSetupMessage();
      await this.sendMessage(setup);
      this.messages.push('Sent SETUP message');

      // Wait for Call Proceeding
      const proceeding = await this.receiveMessage();
      if (!proceeding) {
        return { success: false, error: 'No response from server' };
      }

      const proceedingType = this.getMessageType(proceeding);
      if (proceedingType === Q931MessageType.CALL_PROCEEDING) {
        this.messages.push('Received CALL PROCEEDING');
      } else if (proceedingType === Q931MessageType.RELEASE_COMPLETE) {
        return {
          success: false,
          error: 'Call rejected',
          messages: this.messages,
        };
      }

      // Wait for Alerting (ringing)
      const alerting = await this.receiveMessage();
      if (alerting) {
        const alertingType = this.getMessageType(alerting);
        if (alertingType === Q931MessageType.ALERTING) {
          this.messages.push('Received ALERTING (ringing)');
        }
      }

      // Wait for Connect (answered)
      const connect = await this.receiveMessage();
      if (connect) {
        const connectType = this.getMessageType(connect);
        if (connectType === Q931MessageType.CONNECT) {
          this.messages.push('Received CONNECT (call answered)');
          return {
            success: true,
            callSetup: true,
            messages: this.messages,
          };
        }
      }

      return {
        success: false,
        error: 'Call setup incomplete',
        messages: this.messages,
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        messages: this.messages,
      };
    }
  }

  private buildSetupMessage(): Uint8Array {
    // Simplified H.225 Setup message (Q.931-based)
    // In reality, this would include ASN.1 PER encoded H.323 elements

    const buffer = new Uint8Array(100);
    let offset = 0;

    // Protocol Discriminator (Q.931)
    buffer[offset++] = 0x08;

    // Call Reference Length
    buffer[offset++] = 0x02;

    // Call Reference (2 bytes)
    buffer[offset++] = (this.callRef >> 8) & 0xFF;
    buffer[offset++] = this.callRef & 0xFF;

    // Message Type (Setup)
    buffer[offset++] = Q931MessageType.SETUP;

    // Bearer Capability IE
    buffer[offset++] = 0x04;  // Bearer Capability IE
    buffer[offset++] = 0x03;  // Length
    buffer[offset++] = 0x80;  // Coding: ITU-T
    buffer[offset++] = 0x90;  // Transfer capability: Unrestricted digital
    buffer[offset++] = 0xA5;  // Transfer mode: Packet mode

    // Display IE (optional)
    buffer[offset++] = 0x28;  // Display IE
    const displayText = `Call from ${this.config.callingNumber}`;
    buffer[offset++] = displayText.length;
    const encoder = new TextEncoder();
    const displayBytes = encoder.encode(displayText);
    buffer.set(displayBytes, offset);
    offset += displayBytes.length;

    // Called Party Number IE
    buffer[offset++] = 0x70;  // Called Party Number IE
    buffer[offset++] = this.config.calledNumber.length + 1;
    buffer[offset++] = 0x80;  // Type: Unknown, Plan: Unknown
    const calledBytes = encoder.encode(this.config.calledNumber);
    buffer.set(calledBytes, offset);
    offset += calledBytes.length;

    // Calling Party Number IE
    buffer[offset++] = 0x6C;  // Calling Party Number IE
    buffer[offset++] = this.config.callingNumber.length + 2;
    buffer[offset++] = 0x21;  // Type: National, Plan: ISDN
    buffer[offset++] = 0x80;  // Screening: User-provided, not screened
    const callingBytes = encoder.encode(this.config.callingNumber);
    buffer.set(callingBytes, offset);
    offset += callingBytes.length;

    // User-User IE (H.323 specific information - simplified)
    buffer[offset++] = 0x7E;  // User-User IE
    buffer[offset++] = 0x05;  // Length
    buffer[offset++] = 0x05;  // Protocol discriminator: H.323
    buffer[offset++] = 0x00;  // Reserved
    buffer[offset++] = 0x00;
    buffer[offset++] = 0x00;
    buffer[offset++] = 0x00;

    return buffer.slice(0, offset);
  }

  private getMessageType(data: Uint8Array): number {
    // Message type is at offset 4 (after Protocol Disc, Call Ref Len, Call Ref)
    if (data.length < 5) {
      return 0;
    }
    return data[4];
  }

  private async sendMessage(data: Uint8Array): Promise<void> {
    const writer = this.socket.writable.getWriter();
    await writer.write(data);
    writer.releaseLock();
  }

  private async receiveMessage(): Promise<Uint8Array | null> {
    const reader = this.socket.readable.getReader();
    const { value, done } = await reader.read();
    reader.releaseLock();

    if (done || !value) {
      return null;
    }

    return value;
  }

  async close(): Promise<void> {
    if (this.socket) {
      await this.socket.close();
      this.socket = null;
    }
  }
}

export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/api/h323/call') {
      if (request.method !== 'POST') {
        return new Response('Method not allowed', { status: 405 });
      }

      try {
        const config = await request.json() as H323Config;

        if (!config.server) {
          return new Response(JSON.stringify({ error: 'Server is required' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json' },
          });
        }

        const client = new H323Client(config);
        const response = await client.setupCall();
        await client.close();

        return new Response(JSON.stringify(response), {
          headers: { 'Content-Type': 'application/json' },
        });

      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        });
      }
    }

    return new Response('Not found', { status: 404 });
  },
};
```

## Web UI Design

```typescript
// src/components/H323Tester.tsx
import React, { useState } from 'react';

interface H323Response {
  success: boolean;
  callSetup?: boolean;
  error?: string;
  messages?: string[];
}

export default function H323Tester() {
  const [server, setServer] = useState('');
  const [port, setPort] = useState('1720');
  const [callingNumber, setCallingNumber] = useState('1000');
  const [calledNumber, setCalledNumber] = useState('2000');
  const [loading, setLoading] = useState(false);
  const [response, setResponse] = useState<H323Response | null>(null);

  const handleCall = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setResponse(null);

    try {
      const res = await fetch('/api/h323/call', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          server,
          port: parseInt(port, 10),
          callingNumber,
          calledNumber,
        }),
      });

      const data = await res.json();
      setResponse(data);
    } catch (error) {
      setResponse({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">H.323 Tester</h1>

      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
        <p className="text-sm text-blue-800">
          <strong>H.323</strong> is an ITU-T standard for multimedia communication over packet-switched
          networks. It was widely used for VoIP and video conferencing before SIP became dominant.
        </p>
      </div>

      <form onSubmit={handleCall} className="space-y-4 mb-6">
        <div>
          <label className="block text-sm font-medium mb-2">
            H.323 Gateway/Gatekeeper
          </label>
          <input
            type="text"
            value={server}
            onChange={(e) => setServer(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            placeholder="gatekeeper.example.com"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">
            Port
          </label>
          <input
            type="number"
            value={port}
            onChange={(e) => setPort(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            placeholder="1720"
            min="1"
            max="65535"
            required
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium mb-2">
              Calling Number (From)
            </label>
            <input
              type="text"
              value={callingNumber}
              onChange={(e) => setCallingNumber(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="1000"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">
              Called Number (To)
            </label>
            <input
              type="text"
              value={calledNumber}
              onChange={(e) => setCalledNumber(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="2000"
              required
            />
          </div>
        </div>

        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          {loading ? 'Calling...' : 'Initiate Call'}
        </button>
      </form>

      {/* Response display */}
      {response && (
        <div className={`rounded-lg p-4 ${
          response.success ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'
        }`}>
          <h2 className="font-semibold mb-3">
            {response.success ? '✓ Call Setup Successful' : '✗ Call Failed'}
          </h2>

          {response.messages && response.messages.length > 0 && (
            <div className="mb-3">
              <p className="text-sm font-semibold mb-1">Call Flow:</p>
              <ul className="space-y-1">
                {response.messages.map((msg, idx) => (
                  <li key={idx} className="text-sm font-mono flex items-center">
                    <span className="text-green-600 mr-2">→</span>
                    {msg}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {!response.success && (
            <div className="text-red-800">
              <p className="font-mono text-sm">{response.error}</p>
            </div>
          )}

          {response.success && response.callSetup && (
            <div className="mt-3 pt-3 border-t border-green-200">
              <p className="text-sm text-green-800">
                Call signaling successful. In a real scenario, H.245 control channel would now open
                for capability exchange and media (RTP) streams would be established.
              </p>
            </div>
          )}
        </div>
      )}

      {/* Information boxes */}
      <div className="mt-8 space-y-4">
        <div className="p-4 bg-gray-50 rounded-lg">
          <h3 className="font-semibold mb-2">H.323 Call Flow</h3>
          <ol className="text-sm space-y-1 text-gray-700 list-decimal ml-5">
            <li><strong>Setup:</strong> Caller initiates call (H.225)</li>
            <li><strong>Call Proceeding:</strong> Receiver acknowledges</li>
            <li><strong>Alerting:</strong> Receiver's phone rings</li>
            <li><strong>Connect:</strong> Call answered</li>
            <li><strong>H.245 Open:</strong> Control channel established</li>
            <li><strong>Capabilities Exchange:</strong> Negotiate codecs</li>
            <li><strong>Master/Slave:</strong> Determine call controller</li>
            <li><strong>Open Logical Channels:</strong> Setup media (RTP) streams</li>
            <li><strong>Media Transfer:</strong> Audio/video transmission</li>
            <li><strong>Release Complete:</strong> Hang up</li>
          </ol>
        </div>

        <div className="p-4 bg-gray-50 rounded-lg">
          <h3 className="font-semibold mb-2">H.323 Components</h3>
          <ul className="text-sm space-y-1 text-gray-700">
            <li><strong>Terminal:</strong> Endpoint (phone, softphone, video conferencing system)</li>
            <li><strong>Gateway:</strong> Connects H.323 to PSTN or other networks</li>
            <li><strong>Gatekeeper:</strong> Central management (admission, bandwidth, address translation)</li>
            <li><strong>MCU:</strong> Multipoint Control Unit for conferences (3+ participants)</li>
          </ul>
        </div>

        <div className="p-4 bg-gray-50 rounded-lg">
          <h3 className="font-semibold mb-2">H.323 vs SIP</h3>
          <div className="text-sm space-y-2 text-gray-700">
            <div>
              <strong>H.323:</strong>
              <ul className="list-disc ml-5 mt-1">
                <li>ITU-T standard (telecom industry)</li>
                <li>Binary protocol (ASN.1 PER encoding)</li>
                <li>Complex, feature-rich</li>
                <li>Better interoperability with PSTN/ISDN</li>
                <li>Legacy, being phased out</li>
              </ul>
            </div>
            <div>
              <strong>SIP:</strong>
              <ul className="list-disc ml-5 mt-1">
                <li>IETF standard (internet community)</li>
                <li>Text-based protocol (like HTTP)</li>
                <li>Simpler, more extensible</li>
                <li>Better for internet-based services</li>
                <li>Modern standard, actively developed</li>
              </ul>
            </div>
          </div>
        </div>

        <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
          <h3 className="font-semibold mb-2 text-yellow-900">Legacy Status</h3>
          <p className="text-sm text-yellow-800">
            H.323 is considered legacy. New VoIP deployments should use SIP (RFC 3261) for better
            interoperability, simpler implementation, and industry support.
          </p>
        </div>
      </div>
    </div>
  );
}
```

## Security Considerations

1. **H.235**: H.323 security standard for authentication and encryption
2. **Media Encryption**: Use SRTP for RTP stream encryption
3. **Signaling Encryption**: TLS for H.225/H.245 channels
4. **Authentication**: Gatekeeper authentication (username/password, certificates)
5. **Firewall Traversal**: Complex due to dynamic ports for H.245 and RTP
6. **NAT Issues**: Requires ALG (Application Layer Gateway) or H.460 extensions
7. **DoS Protection**: Rate-limit call attempts
8. **Quality of Service**: Use DiffServ/ToS markings for VoIP traffic priority

## Testing

```bash
# Monitor H.323 traffic
sudo tcpdump -i any port 1720 -w h323.pcap

# Wireshark filters
h225
h245
rtp

# Test with H.323 client (ohphone - deprecated)
# Most testing now done with SIP due to H.323 being legacy

# Test API endpoint
curl -X POST http://localhost:8787/api/h323/call \
  -H "Content-Type: application/json" \
  -d '{
    "server": "gatekeeper.example.com",
    "port": 1720,
    "callingNumber": "1000",
    "calledNumber": "2000"
  }'

# Use commercial tools
# - Polycom RealPresence
# - Cisco video conferencing endpoints
# - Tandberg (now Cisco) systems
```

## Resources

- **ITU-T H.323**: Packet-based multimedia communications systems
- **ITU-T H.225.0**: Call signaling protocols and media stream packetization
- **ITU-T H.245**: Control protocol for multimedia communication
- **ITU-T H.235**: Security framework for H.323
- **ITU-T H.460**: NAT/Firewall traversal extensions
- [Wireshark H.323 Analysis](https://wiki.wireshark.org/H323)
- [OpenH323](http://www.openh323.org/) - Open-source H.323 stack (archived)
- [RFC 3261](https://www.rfc-editor.org/rfc/rfc3261) - SIP (modern alternative)

## Notes

- **Legacy Protocol**: H.323 is being replaced by SIP in most deployments
- **Complex**: Multiple protocols (H.225, H.245, H.235, etc.)
- **ASN.1 Encoding**: Uses Packed Encoding Rules (PER) - complex to implement
- **Dynamic Ports**: H.245 and RTP use dynamically negotiated ports
- **Firewall Challenges**: Requires special handling (ALG) or H.460 extensions
- **Gatekeeper Optional**: Can operate in "direct routed" mode without gatekeeper
- **Video Conferencing**: Still used in some enterprise video systems
- **PSTN Interworking**: Good for connecting to traditional phone networks
- **Q.931 Based**: H.225 call signaling based on ISDN Q.931
- **Zones**: Gatekeepers manage administrative zones
- **FastStart**: Optimization to combine H.225 and H.245 in Setup message
