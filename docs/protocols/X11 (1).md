# X11 Protocol Implementation Plan

## Overview

**Protocol:** X11 (X Window System Protocol)
**Port:** 6000-6063 (TCP), typically 6000 for display :0
**Specification:** [X11 Protocol](https://www.x.org/releases/current/doc/xproto/x11protocol.html)
**Complexity:** Very High
**Purpose:** Graphical display and input

X11 provides **network-transparent windowing** - client-server architecture for displaying graphical applications, handling input events, and managing windows across a network.

### Use Cases
- Remote X applications
- Unix/Linux graphical applications
- X server display forwarding
- Remote desktop (lightweight)
- Graphical application sharing

## Protocol Specification

### Connection Setup

```
1. Client connects to X server (port 6000 + display_number)
2. Client sends connection setup request
3. Server responds with setup reply
4. Client sends requests, server sends replies/events
```

### Connection Setup Request

```
Byte order: 'B' (MSB) or 'l' (LSB)
Protocol major version: 11
Protocol minor version: 0
Authorization protocol name length
Authorization protocol data length
Authorization protocol name
Authorization protocol data
```

### Setup Reply

```
Success: 1
Failure: 0 (with reason)
Authenticate: 2 (with additional auth data)

If success:
  - Protocol version
  - Vendor string
  - Root window ID
  - Visual information
  - Pixmap formats
  - Screen information
```

### Request Format

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Opcode        | Data          |          Length               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Request data                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### Common Opcodes

```
1  - CreateWindow
2  - ChangeWindowAttributes
3  - GetWindowAttributes
4  - DestroyWindow
8  - MapWindow
10 - UnmapWindow
12 - ConfigureWindow
14 - GetGeometry
15 - QueryTree
16 - InternAtom
17 - GetAtomName
18 - ChangeProperty
19 - DeleteProperty
20 - GetProperty
38 - QueryPointer
53 - CreatePixmap
55 - CreateGC
56 - ChangeGC
60 - FreeGC
61 - ClearArea
62 - CopyArea
70 - PolyPoint
64 - PolyLine
65 - PolySegment
67 - PolyFillRectangle
72 - ImageText8
98 - QueryExtension
```

### Event Format

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Event Code    |          Event data (31 bytes)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### Event Types

```
2  - KeyPress
3  - KeyRelease
4  - ButtonPress
5  - ButtonRelease
6  - MotionNotify
7  - EnterNotify
8  - LeaveNotify
12 - Expose
15 - VisibilityNotify
17 - DestroyNotify
19 - MapNotify
22 - ConfigureNotify
28 - PropertyNotify
```

## Worker Implementation

```typescript
// src/worker/protocols/x11/client.ts

import { connect } from 'cloudflare:sockets';

export interface X11Config {
  host: string;
  display?: number; // Display number (default 0)
  screen?: number;  // Screen number (default 0)
  auth?: {
    name: string;   // e.g., "MIT-MAGIC-COOKIE-1"
    data: Uint8Array;
  };
}

// Request Opcodes
export enum X11Opcode {
  CreateWindow = 1,
  ChangeWindowAttributes = 2,
  GetWindowAttributes = 3,
  DestroyWindow = 4,
  MapWindow = 8,
  UnmapWindow = 10,
  ConfigureWindow = 12,
  CreateGC = 55,
  PolyLine = 65,
  PolyFillRectangle = 67,
  ImageText8 = 76,
  QueryExtension = 98,
}

// Event Codes
export enum X11Event {
  KeyPress = 2,
  KeyRelease = 3,
  ButtonPress = 4,
  ButtonRelease = 5,
  MotionNotify = 6,
  Expose = 12,
}

export interface X11Window {
  id: number;
  x: number;
  y: number;
  width: number;
  height: number;
}

export class X11Client {
  private socket: any;
  private sequence: number = 1;
  private rootWindow: number = 0;
  private byteOrder: 'B' | 'l' = 'l'; // Little-endian
  private resourceIdBase: number = 0;
  private resourceIdMask: number = 0;
  private nextResourceId: number = 1;

  constructor(private config: X11Config) {
    if (!config.display) config.display = 0;
    if (!config.screen) config.screen = 0;
  }

  async connect(): Promise<void> {
    const port = 6000 + this.config.display!;
    this.socket = connect(`${this.config.host}:${port}`);
    await this.socket.opened;

    // Send connection setup
    await this.sendSetup();

    // Receive setup reply
    const reply = await this.receiveSetup();

    if (reply.success) {
      console.log('X11 connection established');
      this.rootWindow = reply.rootWindow;
      this.resourceIdBase = reply.resourceIdBase;
      this.resourceIdMask = reply.resourceIdMask;
    } else {
      throw new Error(`X11 connection failed: ${reply.reason}`);
    }
  }

  async createWindow(
    x: number,
    y: number,
    width: number,
    height: number,
    borderWidth: number = 1
  ): Promise<X11Window> {
    const windowId = this.allocateResourceId();

    const buffer = new ArrayBuffer(32);
    const view = new DataView(buffer);
    let offset = 0;

    // Opcode
    view.setUint8(offset++, X11Opcode.CreateWindow);

    // Depth
    view.setUint8(offset++, 24); // 24-bit color

    // Request length (in 4-byte units)
    view.setUint16(offset, 8, this.byteOrder === 'l');
    offset += 2;

    // Window ID
    view.setUint32(offset, windowId, this.byteOrder === 'l');
    offset += 4;

    // Parent (root window)
    view.setUint32(offset, this.rootWindow, this.byteOrder === 'l');
    offset += 4;

    // X, Y
    view.setInt16(offset, x, this.byteOrder === 'l');
    offset += 2;
    view.setInt16(offset, y, this.byteOrder === 'l');
    offset += 2;

    // Width, Height
    view.setUint16(offset, width, this.byteOrder === 'l');
    offset += 2;
    view.setUint16(offset, height, this.byteOrder === 'l');
    offset += 2;

    // Border width
    view.setUint16(offset, borderWidth, this.byteOrder === 'l');
    offset += 2;

    // Window class (InputOutput)
    view.setUint16(offset, 1, this.byteOrder === 'l');
    offset += 2;

    // Visual ID (copy from parent)
    view.setUint32(offset, 0, this.byteOrder === 'l');
    offset += 4;

    // Value mask
    view.setUint32(offset, 0x00000802, this.byteOrder === 'l'); // Background pixel + event mask

    await this.send(new Uint8Array(buffer));

    return { id: windowId, x, y, width, height };
  }

  async mapWindow(windowId: number): Promise<void> {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);

    view.setUint8(0, X11Opcode.MapWindow);
    view.setUint8(1, 0); // Unused
    view.setUint16(2, 2, this.byteOrder === 'l'); // Request length
    view.setUint32(4, windowId, this.byteOrder === 'l');

    await this.send(new Uint8Array(buffer));
  }

  async destroyWindow(windowId: number): Promise<void> {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);

    view.setUint8(0, X11Opcode.DestroyWindow);
    view.setUint8(1, 0);
    view.setUint16(2, 2, this.byteOrder === 'l');
    view.setUint32(4, windowId, this.byteOrder === 'l');

    await this.send(new Uint8Array(buffer));
  }

  async createGC(drawable: number): Promise<number> {
    const gcId = this.allocateResourceId();

    const buffer = new ArrayBuffer(16);
    const view = new DataView(buffer);
    let offset = 0;

    // Opcode
    view.setUint8(offset++, X11Opcode.CreateGC);

    // Unused
    view.setUint8(offset++, 0);

    // Request length
    view.setUint16(offset, 4, this.byteOrder === 'l');
    offset += 2;

    // GC ID
    view.setUint32(offset, gcId, this.byteOrder === 'l');
    offset += 4;

    // Drawable
    view.setUint32(offset, drawable, this.byteOrder === 'l');
    offset += 4;

    // Value mask
    view.setUint32(offset, 0, this.byteOrder === 'l');

    await this.send(new Uint8Array(buffer));

    return gcId;
  }

  async drawLine(
    drawable: number,
    gc: number,
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): Promise<void> {
    const buffer = new ArrayBuffer(20);
    const view = new DataView(buffer);
    let offset = 0;

    // Opcode
    view.setUint8(offset++, X11Opcode.PolyLine);

    // Coordinate mode (Origin)
    view.setUint8(offset++, 0);

    // Request length
    view.setUint16(offset, 5, this.byteOrder === 'l');
    offset += 2;

    // Drawable
    view.setUint32(offset, drawable, this.byteOrder === 'l');
    offset += 4;

    // GC
    view.setUint32(offset, gc, this.byteOrder === 'l');
    offset += 4;

    // Point 1
    view.setInt16(offset, x1, this.byteOrder === 'l');
    offset += 2;
    view.setInt16(offset, y1, this.byteOrder === 'l');
    offset += 2;

    // Point 2
    view.setInt16(offset, x2, this.byteOrder === 'l');
    offset += 2;
    view.setInt16(offset, y2, this.byteOrder === 'l');

    await this.send(new Uint8Array(buffer));
  }

  async drawRectangle(
    drawable: number,
    gc: number,
    x: number,
    y: number,
    width: number,
    height: number,
    filled: boolean = false
  ): Promise<void> {
    const buffer = new ArrayBuffer(20);
    const view = new DataView(buffer);
    let offset = 0;

    // Opcode
    view.setUint8(offset++, filled ? X11Opcode.PolyFillRectangle : 67);

    // Unused
    view.setUint8(offset++, 0);

    // Request length
    view.setUint16(offset, 5, this.byteOrder === 'l');
    offset += 2;

    // Drawable
    view.setUint32(offset, drawable, this.byteOrder === 'l');
    offset += 4;

    // GC
    view.setUint32(offset, gc, this.byteOrder === 'l');
    offset += 4;

    // Rectangle
    view.setInt16(offset, x, this.byteOrder === 'l');
    offset += 2;
    view.setInt16(offset, y, this.byteOrder === 'l');
    offset += 2;
    view.setUint16(offset, width, this.byteOrder === 'l');
    offset += 2;
    view.setUint16(offset, height, this.byteOrder === 'l');

    await this.send(new Uint8Array(buffer));
  }

  async drawText(
    drawable: number,
    gc: number,
    x: number,
    y: number,
    text: string
  ): Promise<void> {
    const textBytes = new TextEncoder().encode(text);
    const padding = (4 - (textBytes.length % 4)) % 4;
    const totalLength = 16 + textBytes.length + padding;

    const buffer = new ArrayBuffer(totalLength);
    const view = new DataView(buffer);
    let offset = 0;

    // Opcode
    view.setUint8(offset++, X11Opcode.ImageText8);

    // Text length
    view.setUint8(offset++, textBytes.length);

    // Request length
    view.setUint16(offset, totalLength / 4, this.byteOrder === 'l');
    offset += 2;

    // Drawable
    view.setUint32(offset, drawable, this.byteOrder === 'l');
    offset += 4;

    // GC
    view.setUint32(offset, gc, this.byteOrder === 'l');
    offset += 4;

    // X, Y
    view.setInt16(offset, x, this.byteOrder === 'l');
    offset += 2;
    view.setInt16(offset, y, this.byteOrder === 'l');
    offset += 2;

    // Text
    new Uint8Array(buffer).set(textBytes, offset);

    await this.send(new Uint8Array(buffer));
  }

  private async sendSetup(): Promise<void> {
    const authName = this.config.auth?.name || '';
    const authData = this.config.auth?.data || new Uint8Array(0);

    const authNamePad = (4 - (authName.length % 4)) % 4;
    const authDataPad = (4 - (authData.length % 4)) % 4;

    const totalLength = 12 + authName.length + authNamePad + authData.length + authDataPad;
    const buffer = new ArrayBuffer(totalLength);
    const view = new DataView(buffer);
    let offset = 0;

    // Byte order
    view.setUint8(offset++, this.byteOrder === 'l' ? 0x6C : 0x42);

    // Unused
    view.setUint8(offset++, 0);

    // Protocol version
    view.setUint16(offset, 11, this.byteOrder === 'l'); // Major
    offset += 2;
    view.setUint16(offset, 0, this.byteOrder === 'l'); // Minor
    offset += 2;

    // Auth name length
    view.setUint16(offset, authName.length, this.byteOrder === 'l');
    offset += 2;

    // Auth data length
    view.setUint16(offset, authData.length, this.byteOrder === 'l');
    offset += 2;

    // Unused
    view.setUint16(offset, 0, this.byteOrder === 'l');
    offset += 2;

    // Auth name
    if (authName.length > 0) {
      const nameBytes = new TextEncoder().encode(authName);
      new Uint8Array(buffer).set(nameBytes, offset);
      offset += authName.length + authNamePad;
    }

    // Auth data
    if (authData.length > 0) {
      new Uint8Array(buffer).set(authData, offset);
    }

    await this.send(new Uint8Array(buffer));
  }

  private async receiveSetup(): Promise<any> {
    const reader = this.socket.readable.getReader();

    // Read first byte (success/failure)
    const { value: firstByte } = await reader.read();
    const success = firstByte[0] === 1;

    if (!success) {
      // Read failure reason
      const { value: reasonLength } = await reader.read();
      // ... read reason string ...
      reader.releaseLock();
      return { success: false, reason: 'Authentication failed' };
    }

    // Read rest of setup (simplified)
    const { value: setupData } = await reader.read();
    reader.releaseLock();

    // Parse setup data (simplified)
    const rootWindow = 0; // Extract from setupData
    const resourceIdBase = 0;
    const resourceIdMask = 0xFFFFFF;

    return {
      success: true,
      rootWindow,
      resourceIdBase,
      resourceIdMask,
    };
  }

  private allocateResourceId(): number {
    const id = this.resourceIdBase | (this.nextResourceId & this.resourceIdMask);
    this.nextResourceId++;
    return id;
  }

  private async send(data: Uint8Array): Promise<void> {
    const writer = this.socket.writable.getWriter();
    await writer.write(data);
    writer.releaseLock();
  }

  async close(): Promise<void> {
    await this.socket.close();
  }
}
```

## Web UI Design

```typescript
// src/components/X11Client.tsx

export function X11Client() {
  const [host, setHost] = useState('');
  const [display, setDisplay] = useState(0);
  const [connected, setConnected] = useState(false);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const connect = async () => {
    const ws = new WebSocket('/api/x11/connect');

    ws.onopen = () => {
      ws.send(JSON.stringify({ host, display }));
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'connected') {
        setConnected(true);
      } else if (data.type === 'expose') {
        // Redraw canvas
        renderX11(data);
      }
    };
  };

  const createWindow = async () => {
    await fetch('/api/x11/create-window', {
      method: 'POST',
      body: JSON.stringify({
        x: 100,
        y: 100,
        width: 640,
        height: 480,
      }),
    });
  };

  return (
    <div className="x11-client">
      <h2>X11 Client</h2>

      {!connected ? (
        <div className="connection">
          <input
            type="text"
            placeholder="X Server Host"
            value={host}
            onChange={(e) => setHost(e.target.value)}
          />
          <input
            type="number"
            placeholder="Display"
            value={display}
            onChange={(e) => setDisplay(Number(e.target.value))}
          />
          <button onClick={connect}>Connect</button>
        </div>
      ) : (
        <div className="x11-session">
          <button onClick={createWindow}>Create Window</button>
          <canvas ref={canvasRef} width={800} height={600} />
        </div>
      )}

      <div className="info">
        <h3>About X11</h3>
        <ul>
          <li>X Window System Protocol</li>
          <li>Network-transparent windowing</li>
          <li>Unix/Linux graphical applications</li>
          <li>Client-server architecture</li>
          <li>Port 6000 + display number</li>
          <li>Used with SSH X11 forwarding</li>
        </ul>
      </div>
    </div>
  );
}
```

## Security

### X11 Authentication

```bash
# MIT-MAGIC-COOKIE-1 (most common)
xauth list

# Generate auth cookie
xauth generate :0 .

# SSH X11 forwarding
ssh -X user@host
```

### Security Concerns

```bash
# X11 has minimal security by default
# Use SSH X11 forwarding for secure transmission
# Or use VNC/RDP for better security
```

## Testing

```bash
# Allow X11 connections
xhost +

# Test X11 connection
DISPLAY=:0 xeyes

# Remote X11
DISPLAY=remote-host:0 xterm

# SSH X11 forwarding
ssh -X user@host
xclock
```

## Resources

- **X.Org**: [X Window System](https://www.x.org/)
- **Xlib**: [X11 library documentation](https://tronche.com/gui/x/xlib/)
- **XCB**: [X C Binding](https://xcb.freedesktop.org/)

## Notes

- **Very complex** - full implementation requires extensive work
- **Client-server** - X server manages display, clients are apps
- **Network transparent** - Applications can run remotely
- **Port 6000+** - Port 6000 for display :0, 6001 for :1, etc.
- **Events** - KeyPress, ButtonPress, Expose, etc.
- **Graphics Context** - GC for drawing operations
- **Window management** - Create, map, configure windows
- **Extensions** - XRENDER, DAMAGE, COMPOSITE, etc.
- **Legacy** - Largely replaced by Wayland on modern Linux
- **SSH forwarding** - Common use case for remote apps
- **Xlib/XCB** - Client libraries for X11
