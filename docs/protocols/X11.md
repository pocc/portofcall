# X11 — X Window System Protocol

**Port:** 6000 + display number (6000–6063)
**Transport:** TCP
**Implementation:** `src/worker/x11.ts`
**Endpoints:** 2

---

## Endpoints

### POST /api/x11/connect

Connection probe. Performs the X11 setup handshake and returns server information (vendor, protocol version, screen geometry, root windows).

**Request:**

```json
{
  "host": "10.0.0.5",
  "port": 6000,
  "display": 0,
  "authName": "MIT-MAGIC-COOKIE-1",
  "authData": "a1b2c3d4e5f6a7b8a1b2c3d4e5f6a7b8",
  "timeout": 10000
}
```

| Field | Type | Default | Notes |
|-------|------|---------|-------|
| `host` | string | — | **Required** |
| `port` | number | `6000 + display` | Overrides display-based calculation when set |
| `display` | number | `0` | Validated 0–63 |
| `authName` | string | _(none)_ | e.g. `"MIT-MAGIC-COOKIE-1"` |
| `authData` | string | _(none)_ | Hex-encoded; whitespace stripped; validated |
| `timeout` | number | `10000` | ms |

**Response (success — status=1):**

```json
{
  "success": true,
  "host": "10.0.0.5",
  "port": 6000,
  "display": 0,
  "connectTime": 12,
  "rtt": 45,
  "status": "connected",
  "protocolVersion": "11.0",
  "vendor": "The X.Org Foundation",
  "releaseNumber": 12101004,
  "maxRequestLength": 65535,
  "imageByteOrder": "LSBFirst",
  "bitmapBitOrder": "LeastSignificant",
  "minKeycode": 8,
  "maxKeycode": 255,
  "numScreens": 1,
  "numFormats": 7,
  "screens": [
    {
      "screen": 0,
      "rootWindow": "0x3e8",
      "resolution": "1920x1080",
      "physicalSize": "530x300mm",
      "rootDepth": 24,
      "whitePixel": "0xffffff",
      "blackPixel": "0x0"
    }
  ]
}
```

**Response (server rejected — status=0):**

```json
{
  "success": true,
  "host": "10.0.0.5",
  "port": 6000,
  "display": 0,
  "connectTime": 12,
  "rtt": 15,
  "status": "rejected",
  "protocolVersion": "11.0",
  "reason": "No protocol specified"
}
```

**Response (auth needed — status=2):**

```json
{
  "success": true,
  "host": "10.0.0.5",
  "port": 6000,
  "display": 0,
  "connectTime": 12,
  "rtt": 14,
  "status": "authenticate",
  "message": "Server requires additional authentication"
}
```

**Gotcha:** `success: true` for all three cases (connected, rejected, authenticate). Only truly unexpected status bytes or errors return `success: false`. Check the `status` field to distinguish outcomes.

---

### POST /api/x11/query-tree

Connects, completes the X11 setup, then:

1. Interns the `_NET_WM_NAME` atom (sequence 1)
2. Sends QueryTree (opcode 15) on the root window (sequence 2)
3. Sends GetProperty (opcode 20) on each child window to retrieve window names

**Request:**

```json
{
  "host": "10.0.0.5",
  "display": 0,
  "maxWindows": 20,
  "timeout": 15000
}
```

| Field | Type | Default | Notes |
|-------|------|---------|-------|
| `host` | string | — | **Required** |
| `port` | number | `6000 + display` | Same override behavior as `/connect` |
| `display` | number | `0` | **Not validated** (no 0–63 check — see quirks) |
| `authName` | string | _(none)_ | Same as `/connect` |
| `authData` | string | _(none)_ | Hex-encoded |
| `maxWindows` | number | `20` | Capped at 50 |
| `timeout` | number | `15000` | ms (affects only TCP connect + setup) |

**Response:**

```json
{
  "success": true,
  "host": "10.0.0.5",
  "port": 6000,
  "display": 0,
  "rootWindow": "0x3e8",
  "vendor": "The X.Org Foundation",
  "protocolVersion": "11.0",
  "screens": [
    { "screen": 0, "resolution": "1920x1080", "rootDepth": 24 }
  ],
  "childCount": 3,
  "windows": [
    { "id": "0x600001", "name": "Firefox" },
    { "id": "0x600045", "name": "Terminal" },
    { "id": "0x600089" }
  ],
  "rtt": 120
}
```

Windows without a name (or whose GetProperty reply timed out) omit the `name` field.

---

## Wire Protocol Details

### Setup Request (always sent)

```
Byte 0:    0x6C ('l' — little-endian)
Bytes 1:   0x00 (unused)
Bytes 2-3: Protocol major version (11)
Bytes 4-5: Protocol minor version (0)
Bytes 6-7: Auth name length
Bytes 8-9: Auth data length
Bytes 10-11: 0x0000 (unused)
Bytes 12+: Auth name (padded to 4-byte boundary)
           Auth data (padded to 4-byte boundary)
```

Always little-endian. No option for big-endian (`'B'`/`0x42`).

### Setup Reply Header (8 bytes)

```
Byte 0:    Status (0=Failed, 1=Success, 2=Authenticate)
Byte 1:    Reason length (if failed) or unused
Bytes 2-3: Protocol major version
Bytes 4-5: Protocol minor version
Bytes 6-7: Additional data length (in 4-byte units)
```

### Parsed Fields from Setup Success

The `parseSetupSuccess()` function extracts from the additional data (38-byte fixed header + vendor string + pixmap formats + screen structures):

| Offset | Bytes | Field |
|--------|-------|-------|
| 0–1 | 2 | protocolMajor |
| 2–3 | 2 | protocolMinor |
| 4–5 | 2 | additional data length (4-byte units) |
| 6–9 | 4 | releaseNumber |
| 10–13 | 4 | resourceIdBase |
| 14–17 | 4 | resourceIdMask |
| 18–21 | 4 | motion buffer size (skipped) |
| 22–23 | 2 | vendorLength |
| 24–25 | 2 | maxRequestLength |
| 26 | 1 | numScreens |
| 27 | 1 | numFormats (pixmap) |
| 28 | 1 | imageByteOrder (0→LSBFirst, 1→MSBFirst) |
| 29 | 1 | bitmapBitOrder (0→LeastSignificant, 1→MostSignificant) |
| 30 | 1 | bitmapScanlineUnit (skipped) |
| 31 | 1 | bitmapScanlinePad (skipped) |
| 32 | 1 | minKeycode |
| 33 | 1 | maxKeycode |
| 34–37 | 4 | unused |
| 38+ | — | vendor string (vendorLength, padded to 4) |
| — | — | pixmap formats (numFormats × 8 bytes each) |
| — | — | screen structures (40 bytes fixed + depth info) |

Each screen structure (40 bytes fixed):

| Offset | Bytes | Field |
|--------|-------|-------|
| 0–3 | 4 | rootWindow |
| 4–7 | 4 | defaultColormap |
| 8–11 | 4 | whitePixel |
| 12–15 | 4 | blackPixel |
| 16–19 | 4 | currentInputMasks (skipped) |
| 20–21 | 2 | widthPixels |
| 22–23 | 2 | heightPixels |
| 24–25 | 2 | widthMM |
| 26–27 | 2 | heightMM |
| 28–29 | 2 | minInstalledMaps (skipped) |
| 30–31 | 2 | maxInstalledMaps (skipped) |
| 32–35 | 4 | rootVisual (skipped) |
| 36 | 1 | backingStores (skipped) |
| 37 | 1 | saveUnders (skipped) |
| 38 | 1 | rootDepth |
| 39 | 1 | numDepths |

Depth info is variable-length: 8 bytes per depth + `numVisuals × 24` bytes per visual type.

### QueryTree Reply (opcode 15)

32-byte header + body:

```
Bytes 0:    1 (reply)
Bytes 1:    unused
Bytes 2-3:  sequence number
Bytes 4-7:  additional data length (4-byte units)
Bytes 8-11: root window
Bytes 12-15: parent window
Bytes 16-17: number of children
Bytes 18-31: unused
Bytes 32+:  child window IDs (nChildren × 4 bytes)
```

### GetProperty Reply (opcode 20)

```
Bytes 0:    1 (reply)
Bytes 1:    format (8/16/32)
Bytes 2-3:  sequence number
Bytes 4-7:  additional data length
Bytes 8-11: type atom
Bytes 12-15: bytes-after (remaining data not returned)
Bytes 16-19: value length (in format-units)
Bytes 20-31: unused
Bytes 32+:  property value
```

Value decoded as UTF-8 (`fatal: false`), NUL bytes stripped, trimmed. Values ≥1024 bytes silently ignored.

---

## Opcodes Used

| Opcode | Name | Where Used |
|--------|------|------------|
| 15 | QueryTree | `/query-tree` — list child windows of root |
| 16 | InternAtom | `/query-tree` — resolve `_NET_WM_NAME` atom |
| 20 | GetProperty | `/query-tree` — read window names |

### Atom Fallback

`/query-tree` interns `_NET_WM_NAME` first (UTF-8 window titles). If InternAtom fails or returns atom 0, falls back to predefined atom 39 (`WM_NAME`, Latin-1 window titles). The InternAtom request uses `only-if-exists=False`, which will create the atom on the server if it doesn't already exist — harmless but technically unnecessary for a read-only probe.

---

## Cross-Endpoint Comparison

| | `/connect` | `/query-tree` |
|---|---|---|
| Default timeout | 10,000 ms | 15,000 ms |
| Display validation | 0–63 | **None** |
| Port validation | 1–65535 | 1–65535 |
| Auth data hex validation | Yes (returns 400) | No (unhandled throw → 500) |
| Cloudflare detection | No | No |
| HTTP method check | No | No |
| Response `connectTime` | Yes | No |
| Response `screens` detail | Full (rootWindow, resolution, physicalSize, rootDepth, whitePixel, blackPixel) | Abbreviated (screen index, resolution, rootDepth) |

---

## Timeout Architecture

**`/connect`:** Single timeout (default 10s) governs the entire TCP connect + setup handshake. Created once via `setTimeout()`.

**`/query-tree`:** The main `timeout` parameter (default 15s) governs only TCP connect + the setup handshake. The subsequent X11 operations each have their own **hardcoded, independent timeouts**:

| Operation | Hardcoded Timeout | Notes |
|-----------|-------------------|-------|
| InternAtom reply | 5,000 ms | Failure silently falls back to WM_NAME (atom 39) |
| QueryTree reply | 8,000 ms | Failure returns empty `windows` array |
| GetProperty reply (per window) | 2,000 ms | Failure returns window entry without `name` |

These inner timeouts are not configurable. A user setting `timeout: 60000` only extends the initial handshake, not the per-operation timeouts.

Worst-case wall time for `/query-tree` with 50 windows: `timeout` + 5s + 8s + (50 × 2s) = `timeout` + 113s.

---

## Known Quirks and Limitations

1. **`success: true` on rejection/auth-needed.** `/connect` returns `success: true` for all three X11 setup outcomes: `connected` (status=1), `rejected` (status=0), and `authenticate` (status=2). Only TCP errors, unexpected status bytes, or internal errors return `success: false`. Always check the `status` field.

2. **Display validation gap.** `/connect` validates `display` is 0–63. `/query-tree` accepts any integer, so `display: 100` → port 6100 without complaint.

3. **`authData` hex validation gap.** `/connect` validates hex format and returns HTTP 400 on invalid hex. `/query-tree` passes raw `body.authData` through `hexToBytes()` without a try/catch — invalid hex will throw an unhandled error and return HTTP 500 instead of 400.

4. **`port` overrides `display` silently.** If both `port` and `display` are provided, `port` wins (`if (!port) port = 6000 + display`). But `display` is still echoed in the response, which could mislead callers into thinking it affected port selection.

5. **Little-endian only.** Both endpoints hardcode byte order `0x6C` ('l'). No way to request big-endian negotiation. This is fine for all modern X servers.

6. **No Cloudflare detection.** Neither endpoint calls `checkIfCloudflare()`.

7. **No HTTP method restriction.** Both endpoints respond to any method (GET, PUT, DELETE, etc.).

8. **readExact excess-byte discard.** The `readExact()` helper reads exactly N bytes. If a TCP segment delivers more data than the current read needs, excess bytes are silently discarded. Works for the sequential setup flow but could cause data loss if server responses are fragmented differently than expected.

9. **64 KB reply limit.** `readX11Reply()` rejects any reply with additional data > 65,536 bytes. This is a safety limit and sufficient for typical QueryTree/GetProperty responses, but very large window trees (thousands of children) could exceed it.

10. **GetProperty 512-byte value cap.** The GetProperty request uses `long-length=128` (128 × 4 = 512 bytes of value data). Window names exceeding 512 bytes are truncated. Additionally, values ≥1024 bytes in the reply are silently ignored (no name returned).

11. **No XAUTHORITY file parsing.** The user must extract the MIT-MAGIC-COOKIE-1 cookie value manually (via `xauth list`) and provide it as hex. No `.Xauthority` file reading.

12. **No host regex restriction.** Unlike many other protocol implementations in this codebase, X11 does not validate the `host` parameter against any regex pattern.

13. **Single-level QueryTree.** `/query-tree` only queries direct children of the root window. Nested child windows (e.g., dialog boxes parented to application frames) are not enumerated. Recursive tree walking is not supported.

14. **No event handling.** The implementation sends requests and reads replies only. X11 events (KeyPress, Expose, etc.) arriving on the socket between replies could cause reply parsing to fail, since `readX11Reply()` checks `header[0] !== 1` and returns the 32-byte event as-is.

---

## Examples

### Probe an open X11 server

```bash
curl -X POST https://portofcall.dev/api/x11/connect \
  -H 'Content-Type: application/json' \
  -d '{"host": "10.0.0.5", "display": 0}'
```

### Probe with MIT-MAGIC-COOKIE-1 auth

```bash
# Extract cookie: xauth list → hex value after "MIT-MAGIC-COOKIE-1"
curl -X POST https://portofcall.dev/api/x11/connect \
  -H 'Content-Type: application/json' \
  -d '{
    "host": "10.0.0.5",
    "display": 0,
    "authName": "MIT-MAGIC-COOKIE-1",
    "authData": "a1b2c3d4e5f6a7b8a1b2c3d4e5f6a7b8"
  }'
```

### List windows on a remote display

```bash
curl -X POST https://portofcall.dev/api/x11/query-tree \
  -H 'Content-Type: application/json' \
  -d '{"host": "10.0.0.5", "display": 0, "maxWindows": 50}'
```

### Use explicit port (X11 over SSH tunnel)

```bash
# SSH: ssh -L 6010:localhost:6000 user@remote
curl -X POST https://portofcall.dev/api/x11/connect \
  -H 'Content-Type: application/json' \
  -d '{"host": "127.0.0.1", "port": 6010}'
```

---

## Local Testing

```bash
# Start Xvfb (headless X server, no auth)
Xvfb :99 -screen 0 1024x768x24 &
export DISPLAY=:99

# Open some windows
xterm &
xclock &

# Probe
curl -s localhost:8787/api/x11/connect \
  -d '{"host":"127.0.0.1","display":99}' | jq .

# List windows
curl -s localhost:8787/api/x11/query-tree \
  -d '{"host":"127.0.0.1","display":99}' | jq .windows
```
